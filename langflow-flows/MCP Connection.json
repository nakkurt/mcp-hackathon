{"name": "MCP Connection", "description": "Connect to an MCP server to use its tools.", "icon": null, "icon_bg_color": null, "gradient": null, "data": {"edges": [], "nodes": [{"data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "import re\nfrom typing import Any\n\nfrom langchain_core.tools import StructuredTool\n\nfrom langflow.base.mcp.util import (\n    MCPSseClient,\n    MCPStdioClient,\n    create_input_schema_from_json_schema,\n    create_tool_coroutine,\n    create_tool_func,\n)\nfrom langflow.custom import Component\nfrom langflow.inputs import DropdownInput, TableInput\nfrom langflow.inputs.inputs import InputTypes\nfrom langflow.io import MessageTextInput, MultilineInput, Output, TabInput\nfrom langflow.io.schema import flatten_schema, schema_to_langflow_inputs\nfrom langflow.logging import logger\nfrom langflow.schema import Message\n\n\ndef maybe_unflatten_dict(flat: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"If any key looks nested (contains a dot or \u201c[index]\u201d), rebuild the.\n\n    full nested structure; otherwise return flat as is.\n    \"\"\"\n    # Quick check: do we have any nested keys?\n    if not any(re.search(r\"\\.|\\[\\d+\\]\", key) for key in flat):\n        return flat\n\n    # Otherwise, unflatten into dicts/lists\n    nested: dict[str, Any] = {}\n    array_re = re.compile(r\"^(.+)\\[(\\d+)\\]$\")\n\n    for key, val in flat.items():\n        parts = key.split(\".\")\n        cur = nested\n        for i, part in enumerate(parts):\n            m = array_re.match(part)\n            # Array segment?\n            if m:\n                name, idx = m.group(1), int(m.group(2))\n                lst = cur.setdefault(name, [])\n                # Ensure list is big enough\n                while len(lst) <= idx:\n                    lst.append({})\n                if i == len(parts) - 1:\n                    lst[idx] = val\n                else:\n                    cur = lst[idx]\n            # Normal object key\n            elif i == len(parts) - 1:\n                cur[part] = val\n            else:\n                cur = cur.setdefault(part, {})\n\n    return nested\n\n\nclass MCPToolsComponent(Component):\n    schema_inputs: list[InputTypes] = []\n    stdio_client: MCPStdioClient = MCPStdioClient()\n    sse_client: MCPSseClient = MCPSseClient()\n    tools: list = []\n    tool_names: list[str] = []\n    _tool_cache: dict = {}  # Cache for tool objects\n    default_keys: list[str] = [\n        \"code\",\n        \"_type\",\n        \"mode\",\n        \"command\",\n        \"env\",\n        \"sse_url\",\n        \"tool_placeholder\",\n        \"tool_mode\",\n        \"tool\",\n        \"headers_input\",\n    ]\n\n    display_name = \"MCP Connection\"\n    description = \"Connect to an MCP server to use its tools.\"\n    icon = \"Mcp\"\n    name = \"MCPTools\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Stdio\", \"SSE\"],\n            value=\"Stdio\",\n            info=\"Select the connection mode\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"command\",\n            display_name=\"MCP Command\",\n            info=\"Command for MCP stdio connection\",\n            value=\"uvx mcp-server-fetch\",\n            show=True,\n            refresh_button=True,\n        ),\n        MessageTextInput(\n            name=\"env\",\n            display_name=\"Env\",\n            info=\"Env vars to include in mcp stdio connection (i.e. DEBUG=true)\",\n            value=\"\",\n            is_list=True,\n            show=True,\n            tool_mode=False,\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"sse_url\",\n            display_name=\"MCP SSE URL\",\n            info=\"URL for MCP SSE connection\",\n            show=False,\n            refresh_button=True,\n            value=\"MCP_SSE\",\n            real_time_refresh=True,\n        ),\n        TableInput(\n            name=\"headers_input\",\n            display_name=\"Headers\",\n            info=\"Headers to include in the tool\",\n            show=False,\n            real_time_refresh=True,\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[],\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"tool\",\n            display_name=\"Tool\",\n            options=[],\n            value=\"\",\n            info=\"Select the tool to execute\",\n            show=True,\n            required=True,\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            info=\"Placeholder for the tool\",\n            value=\"\",\n            show=False,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Response\", name=\"response\", method=\"build_output\"),\n    ]\n\n    async def _validate_connection_params(self, mode: str, command: str | None = None, url: str | None = None) -> None:\n        \"\"\"Validate connection parameters based on mode.\"\"\"\n        if mode not in [\"Stdio\", \"SSE\"]:\n            msg = f\"Invalid mode: {mode}. Must be either 'Stdio' or 'SSE'\"\n            raise ValueError(msg)\n\n        if mode == \"Stdio\" and not command:\n            msg = \"Command is required for Stdio mode\"\n            raise ValueError(msg)\n        if mode == \"SSE\" and not url:\n            msg = \"URL is required for SSE mode\"\n            raise ValueError(msg)\n\n    def _process_headers(self, headers: Any) -> dict:\n        \"\"\"Process the headers input into a valid dictionary.\n\n        Args:\n            headers: The headers to process, can be dict, str, or list\n        Returns:\n            Processed dictionary\n        \"\"\"\n        if headers is None:\n            return {}\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            processed_headers = {}\n            try:\n                for item in headers:\n                    if not self._is_valid_key_value_item(item):\n                        continue\n                    key = item[\"key\"]\n                    value = item[\"value\"]\n                    processed_headers[key] = value\n            except (KeyError, TypeError, ValueError) as e:\n                self.log(f\"Failed to process headers list: {e}\")\n                return {}  # Return empty dictionary instead of None\n            return processed_headers\n        return {}\n\n    def _is_valid_key_value_item(self, item: Any) -> bool:\n        \"\"\"Check if an item is a valid key-value dictionary.\"\"\"\n        return isinstance(item, dict) and \"key\" in item and \"value\" in item\n\n    async def _validate_schema_inputs(self, tool_obj) -> list[InputTypes]:\n        \"\"\"Validate and process schema inputs for a tool.\"\"\"\n        try:\n            if not tool_obj or not hasattr(tool_obj, \"inputSchema\"):\n                msg = \"Invalid tool object or missing input schema\"\n                raise ValueError(msg)\n\n            flat_schema = flatten_schema(tool_obj.inputSchema)\n            input_schema = create_input_schema_from_json_schema(flat_schema)\n            if not input_schema:\n                msg = f\"Empty input schema for tool '{tool_obj.name}'\"\n                raise ValueError(msg)\n\n            schema_inputs = schema_to_langflow_inputs(input_schema)\n            if not schema_inputs:\n                msg = f\"No input parameters defined for tool '{tool_obj.name}'\"\n                logger.warning(msg)\n                return []\n\n        except Exception as e:\n            msg = f\"Error validating schema inputs: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n        else:\n            return schema_inputs\n\n    async def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        \"\"\"Toggle the visibility of connection-specific fields based on the selected mode.\"\"\"\n        try:\n            if field_name == \"mode\":\n                self.remove_non_default_keys(build_config)\n                build_config[\"tool\"][\"options\"] = []\n                if field_value == \"Stdio\":\n                    build_config[\"command\"][\"show\"] = True\n                    build_config[\"env\"][\"show\"] = True\n                    build_config[\"headers_input\"][\"show\"] = False\n                    build_config[\"sse_url\"][\"show\"] = False\n                elif field_value == \"SSE\":\n                    build_config[\"command\"][\"show\"] = False\n                    build_config[\"env\"][\"show\"] = False\n                    build_config[\"sse_url\"][\"show\"] = True\n                    build_config[\"sse_url\"][\"value\"] = \"MCP_SSE\"\n                    build_config[\"headers_input\"][\"show\"] = True\n                    return build_config\n            if field_name in (\"command\", \"sse_url\", \"mode\"):\n                try:\n                    await self.update_tools(\n                        mode=build_config[\"mode\"][\"value\"],\n                        command=build_config[\"command\"][\"value\"],\n                        url=build_config[\"sse_url\"][\"value\"],\n                        env=build_config[\"env\"][\"value\"],\n                        headers=build_config[\"headers_input\"][\"value\"],\n                    )\n                    if \"tool\" in build_config:\n                        build_config[\"tool\"][\"options\"] = self.tool_names\n                except Exception as e:\n                    build_config[\"tool\"][\"options\"] = []\n                    msg = f\"Failed to update tools: {e!s}\"\n                    raise ValueError(msg) from e\n                else:\n                    return build_config\n            elif field_name == \"tool\":\n                if len(self.tools) == 0:\n                    await self.update_tools(\n                        mode=build_config[\"mode\"][\"value\"],\n                        command=build_config[\"command\"][\"value\"],\n                        url=build_config[\"sse_url\"][\"value\"],\n                        env=build_config[\"env\"][\"value\"],\n                        headers=build_config[\"headers_input\"][\"value\"],\n                    )\n                if self.tool is None:\n                    return build_config\n                tool_obj = None\n                for tool in self.tools:\n                    if tool.name == self.tool:\n                        tool_obj = tool\n                        break\n                if tool_obj is None:\n                    msg = f\"Tool {self.tool} not found in available tools: {self.tools}\"\n                    logger.warning(msg)\n                    return build_config\n                self.remove_non_default_keys(build_config)\n                await self._update_tool_config(build_config, field_value)\n            elif field_name == \"tool_mode\":\n                build_config[\"tool\"][\"show\"] = not field_value\n                for key, value in list(build_config.items()):\n                    if key not in self.default_keys and isinstance(value, dict) and \"show\" in value:\n                        build_config[key][\"show\"] = not field_value\n\n        except Exception as e:\n            msg = f\"Error in update_build_config: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n        else:\n            return build_config\n\n    def get_inputs_for_all_tools(self, tools: list) -> dict:\n        \"\"\"Get input schemas for all tools.\"\"\"\n        inputs = {}\n        for tool in tools:\n            if not tool or not hasattr(tool, \"name\"):\n                continue\n            try:\n                flat_schema = flatten_schema(tool.inputSchema)\n                input_schema = create_input_schema_from_json_schema(flat_schema)\n                langflow_inputs = schema_to_langflow_inputs(input_schema)\n                inputs[tool.name] = langflow_inputs\n            except (AttributeError, ValueError, TypeError, KeyError) as e:\n                msg = f\"Error getting inputs for tool {getattr(tool, 'name', 'unknown')}: {e!s}\"\n                logger.exception(msg)\n                continue\n        return inputs\n\n    def remove_input_schema_from_build_config(\n        self, build_config: dict, tool_name: str, input_schema: dict[list[InputTypes], Any]\n    ):\n        \"\"\"Remove the input schema for the tool from the build config.\"\"\"\n        # Keep only schemas that don't belong to the current tool\n        input_schema = {k: v for k, v in input_schema.items() if k != tool_name}\n        # Remove all inputs from other tools\n        for value in input_schema.values():\n            for _input in value:\n                if _input.name in build_config:\n                    build_config.pop(_input.name)\n\n    def remove_non_default_keys(self, build_config: dict) -> None:\n        \"\"\"Remove non-default keys from the build config.\"\"\"\n        for key in list(build_config.keys()):\n            if key not in self.default_keys:\n                build_config.pop(key)\n\n    async def _update_tool_config(self, build_config: dict, tool_name: str) -> None:\n        \"\"\"Update tool configuration with proper error handling.\"\"\"\n        if not self.tools:\n            await self.update_tools(\n                mode=build_config[\"mode\"][\"value\"],\n                command=build_config[\"command\"][\"value\"],\n                url=build_config[\"sse_url\"][\"value\"],\n                env=build_config[\"env\"][\"value\"],\n                headers=build_config[\"headers_input\"][\"value\"],\n            )\n\n        if not tool_name:\n            return\n\n        tool_obj = next((tool for tool in self.tools if tool.name == tool_name), None)\n        if not tool_obj:\n            msg = f\"Tool {tool_name} not found in available tools: {self.tools}\"\n            logger.warning(msg)\n            return\n\n        try:\n            # Get all tool inputs and remove old ones\n            input_schema_for_all_tools = self.get_inputs_for_all_tools(self.tools)\n            self.remove_input_schema_from_build_config(build_config, tool_name, input_schema_for_all_tools)\n\n            # Get and validate new inputs\n            self.schema_inputs = await self._validate_schema_inputs(tool_obj)\n            if not self.schema_inputs:\n                msg = f\"No input parameters to configure for tool '{tool_name}'\"\n                logger.info(msg)\n                return\n\n            # Add new inputs to build config\n            for schema_input in self.schema_inputs:\n                if not schema_input or not hasattr(schema_input, \"name\"):\n                    msg = \"Invalid schema input detected, skipping\"\n                    logger.warning(msg)\n                    continue\n\n                try:\n                    name = schema_input.name\n                    input_dict = schema_input.to_dict()\n                    input_dict.setdefault(\"value\", None)\n                    input_dict.setdefault(\"required\", True)\n                    build_config[name] = input_dict\n                except (AttributeError, KeyError, TypeError) as e:\n                    msg = f\"Error processing schema input {schema_input}: {e!s}\"\n                    logger.exception(msg)\n                    continue\n        except ValueError as e:\n            msg = f\"Schema validation error for tool {tool_name}: {e!s}\"\n            logger.exception(msg)\n            self.schema_inputs = []\n            return\n        except (AttributeError, KeyError, TypeError) as e:\n            msg = f\"Error updating tool config: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n    async def build_output(self) -> Message:\n        \"\"\"Build output with improved error handling and validation.\"\"\"\n        try:\n            await self.update_tools()\n            if self.tool != \"\":\n                exec_tool = self._tool_cache[self.tool]\n                tool_args = self.get_inputs_for_all_tools(self.tools)[self.tool]\n                kwargs = {}\n                for arg in tool_args:\n                    value = getattr(self, arg.name, None)\n                    if value:\n                        kwargs[arg.name] = value\n\n                unflattened_kwargs = maybe_unflatten_dict(kwargs)\n\n                output = await exec_tool.coroutine(**unflattened_kwargs)\n\n                return Message(text=output.content[len(output.content) - 1].text)\n            return Message(text=\"You must select a tool\", error=True)\n        except Exception as e:\n            msg = f\"Error in build_output: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n\n    async def update_tools(\n        self,\n        mode: str | None = None,\n        command: str | None = None,\n        url: str | None = None,\n        env: list[str] | None = None,\n        headers: dict[str, str] | None = None,\n    ) -> list[StructuredTool]:\n        \"\"\"Connect to the MCP server and update available tools with improved error handling.\"\"\"\n        try:\n            if mode is None:\n                mode = self.mode\n            if command is None:\n                command = self.command\n            if env is None:\n                env = self.env\n            if url is None:\n                url = self.sse_url\n            if headers is None:\n                headers = self.headers_input\n            headers = self._process_headers(headers)\n            await self._validate_connection_params(mode, command, url)\n\n            if mode == \"Stdio\":\n                if not self.stdio_client.session:\n                    self.tools = await self.stdio_client.connect_to_server(command, env)\n            elif mode == \"SSE\" and not self.sse_client.session:\n                try:\n                    self.tools = await self.sse_client.connect_to_server(url, headers)\n                except ValueError as e:\n                    # URL validation error\n                    logger.error(f\"SSE URL validation error: {e}\")\n                    msg = f\"Invalid SSE URL configuration: {e}. Please check your Langflow deployment URL and port.\"\n                    raise ValueError(msg) from e\n                except ConnectionError as e:\n                    # Connection failed after retries\n                    logger.error(f\"SSE connection error: {e}\")\n                    msg = (\n                        f\"Could not connect to Langflow SSE endpoint: {e}. \"\n                        \"Please verify:\\n\"\n                        \"1. Langflow server is running\\n\"\n                        \"2. The SSE URL matches your Langflow deployment port\\n\"\n                        \"3. There are no network issues preventing the connection\"\n                    )\n                    raise ValueError(msg) from e\n                except Exception as e:\n                    logger.error(f\"Unexpected SSE error: {e}\")\n                    msg = f\"Unexpected error connecting to SSE endpoint: {e}\"\n                    raise ValueError(msg) from e\n\n            if not self.tools:\n                logger.warning(\"No tools returned from server\")\n                return []\n\n            tool_list = []\n            for tool in self.tools:\n                if not tool or not hasattr(tool, \"name\"):\n                    logger.warning(\"Invalid tool object detected, skipping\")\n                    continue\n\n                try:\n                    args_schema = create_input_schema_from_json_schema(tool.inputSchema)\n                    if not args_schema:\n                        logger.warning(f\"Empty schema for tool '{tool.name}', skipping\")\n                        continue\n\n                    client = self.stdio_client if self.mode == \"Stdio\" else self.sse_client\n                    if not client or not client.session:\n                        msg = f\"Invalid client session for tool '{tool.name}'\"\n                        raise ValueError(msg)\n\n                    tool_obj = StructuredTool(\n                        name=tool.name,\n                        description=tool.description or \"\",\n                        args_schema=args_schema,\n                        func=create_tool_func(tool.name, args_schema, client.session),\n                        coroutine=create_tool_coroutine(tool.name, args_schema, client.session),\n                        tags=[tool.name],\n                        metadata={},\n                    )\n                    tool_list.append(tool_obj)\n                    self._tool_cache[tool.name] = tool_obj\n                except (AttributeError, ValueError, TypeError, KeyError) as e:\n                    msg = f\"Error creating tool {getattr(tool, 'name', 'unknown')}: {e}\"\n                    logger.exception(msg)\n                    continue\n\n            self.tool_names = [tool.name for tool in self.tools if hasattr(tool, \"name\")]\n\n        except ValueError as e:\n            # Re-raise validation errors with clear messages\n            raise ValueError(str(e)) from e\n        except Exception as e:\n            logger.exception(\"Error updating tools\")\n            msg = f\"Failed to update tools: {e!s}\"\n            raise ValueError(msg) from e\n        else:\n            return tool_list\n\n    async def _get_tools(self):\n        \"\"\"Get cached tools or update if necessary.\"\"\"\n        # if not self.tools:\n        if self.mode == \"SSE\" and self.sse_url is None:\n            msg = \"SSE URL is not set\"\n            raise ValueError(msg)\n        return await self.update_tools()\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "command": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "command", "value": "Notion MCP Command", "display_name": "MCP Command", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "Command for MCP stdio connection", "refresh_button": true, "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "env": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": true, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "env", "value": ["NOTION_KEY=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"], "display_name": "Env", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "Env vars to include in mcp stdio connection (i.e. DEBUG=true)", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "headers_input": {"tool_mode": false, "is_list": true, "list_add_label": "Add More", "table_schema": {"columns": [{"name": "key", "display_name": "Header", "sortable": true, "filterable": true, "formatter": "text", "type": "str", "description": "Header name", "default": "None", "disable_edit": false, "edit_mode": "popover", "hidden": false}, {"name": "value", "display_name": "Value", "sortable": true, "filterable": true, "formatter": "text", "type": "str", "description": "Header value", "default": "None", "disable_edit": false, "edit_mode": "popover", "hidden": false}]}, "trigger_text": "Open table", "trigger_icon": "Table", "table_icon": "Table", "trace_as_metadata": true, "required": false, "placeholder": "", "show": false, "name": "headers_input", "value": [], "display_name": "Headers", "advanced": true, "dynamic": false, "info": "Headers to include in the tool", "real_time_refresh": true, "title_case": false, "type": "table", "_input_type": "TableInput"}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Stdio", "SSE"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Stdio", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Select the connection mode", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "sse_url": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": false, "name": "sse_url", "value": "MCP_SSE", "display_name": "MCP SSE URL", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "URL for MCP SSE connection", "real_time_refresh": true, "refresh_button": true, "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "tool": {"tool_mode": false, "trace_as_metadata": true, "options": ["API-get-user", "API-get-users", "API-get-self", "API-post-database-query", "API-post-search", "API-get-block-children", "API-patch-block-children", "API-retrieve-a-block", "API-update-a-block", "API-delete-a-block", "API-retrieve-a-page", "API-patch-page", "API-post-page", "API-create-a-database", "API-update-a-database", "API-retrieve-a-database", "API-retrieve-a-page-property", "API-retrieve-a-comment", "API-create-a-comment"], "options_metadata": [], "combobox": false, "dialog_inputs": {}, "toggle": false, "required": true, "placeholder": "", "show": false, "name": "tool", "value": "API-retrieve-a-page", "display_name": "Tool", "advanced": false, "dynamic": false, "info": "Select the tool to execute", "real_time_refresh": true, "title_case": false, "type": "str", "_input_type": "DropdownInput"}, "tool_placeholder": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": false, "name": "tool_placeholder", "value": "", "display_name": "Tool Placeholder", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "Placeholder for the tool", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "page_id": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": false, "name": "page_id", "value": "", "display_name": "Page Id", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "Identifier for a Notion page", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "filter_properties": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": false, "name": "filter_properties", "value": "", "display_name": "Filter Properties", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "A list of page property value IDs associated with the page. Use this param to limit the response to a specific page property value or values. To retrieve multiple properties, specify each page property ID. For example: `?filter_properties=iAk8&filter_properties=b7dh`.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "tools_metadata": {"tool_mode": false, "trace_as_metadata": true, "is_list": true, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "tools_metadata", "value": [{"name": "API-get-user", "description": "Retrieve a user\nError Responses:\n400: 400", "tags": ["API-get-user"], "status": true, "display_name": "API-get-user", "display_description": "Retrieve a user\nError Responses:\n400: 400", "readonly": false, "args": {"user_id": {"title": "User Id", "type": "string"}}}, {"name": "API-get-users", "description": "List all users\nError Responses:\n400: 400", "tags": ["API-get-users"], "status": true, "display_name": "API-get-users", "display_description": "List all users\nError Responses:\n400: 400", "readonly": false, "args": {"start_cursor": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "If supplied, this endpoint will return a page of results starting after the cursor provided. If not supplied, this endpoint will return the first page of results.", "title": "Start Cursor"}, "page_size": {"anyOf": [{"type": "integer"}, {"type": "null"}], "default": 100, "description": "The number of items from the full list desired in the response. Maximum: 100", "title": "Page Size"}}}, {"name": "API-get-self", "description": "Retrieve your token's bot user", "tags": ["API-get-self"], "status": true, "display_name": "API-get-self", "display_description": "Retrieve your token's bot user", "readonly": false, "args": {}}, {"name": "API-post-database-query", "description": "Query a database", "tags": ["API-post-database-query"], "status": true, "display_name": "API-post-database-query", "display_description": "Query a database", "readonly": false, "args": {"database_id": {"description": "Identifier for a Notion database.", "title": "Database Id", "type": "string"}, "filter_properties": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "default": null, "description": "A list of page property value IDs associated with the database. Use this param to limit the response to a specific page property value or values for pages that meet the `filter` criteria.", "title": "Filter Properties"}, "filter": {"anyOf": [{"$ref": "#/$defs/AnonModel0"}, {"type": "null"}], "default": null, "description": "When supplied, limits which pages are returned based on the [filter conditions](ref:post-database-query-filter)."}, "sorts": {"anyOf": [{"items": {"$ref": "#/$defs/AnonModel1"}, "type": "array"}, {"type": "null"}], "default": null, "description": "When supplied, orders the results based on the provided [sort criteria](ref:post-database-query-sort).", "title": "Sorts"}, "start_cursor": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "When supplied, returns a page of results starting after the cursor provided. If not supplied, this endpoint will return the first page of results.", "title": "Start Cursor"}, "page_size": {"anyOf": [{"type": "integer"}, {"type": "null"}], "default": 100, "description": "The number of items from the full list desired in the response. Maximum: 100", "title": "Page Size"}, "archived": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "default": null, "title": "Archived"}, "in_trash": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "default": null, "title": "In Trash"}}}, {"name": "API-post-search", "description": "Search by title", "tags": ["API-post-search"], "status": true, "display_name": "API-post-search", "display_description": "Search by title", "readonly": false, "args": {"query": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "The text that the API compares page and database titles against.", "title": "Query"}, "sort": {"anyOf": [{"$ref": "#/$defs/AnonModel0"}, {"type": "null"}], "default": null, "description": "A set of criteria, `direction` and `timestamp` keys, that orders the results. The **only** supported timestamp value is `\"last_edited_time\"`. Supported `direction` values are `\"ascending\"` and `\"descending\"`. If `sort` is not provided, then the most recently edited results are returned first."}, "filter": {"anyOf": [{"$ref": "#/$defs/AnonModel1"}, {"type": "null"}], "default": null, "description": "A set of criteria, `value` and `property` keys, that limits the results to either only pages or only databases. Possible `value` values are `\"page\"` or `\"database\"`. The only supported `property` value is `\"object\"`."}, "start_cursor": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "A `cursor` value returned in a previous response that If supplied, limits the response to results starting after the `cursor`. If not supplied, then the first page of results is returned. Refer to [pagination](https://developers.notion.com/reference/intro#pagination) for more details.", "title": "Start Cursor"}, "page_size": {"anyOf": [{"type": "integer"}, {"type": "null"}], "default": 100, "description": "The number of items from the full list to include in the response. Maximum: `100`.", "title": "Page Size"}}}, {"name": "API-get-block-children", "description": "Retrieve block children", "tags": ["API-get-block-children"], "status": true, "display_name": "API-get-block-children", "display_description": "Retrieve block children", "readonly": false, "args": {"block_id": {"description": "Identifier for a [block](ref:block)", "title": "Block Id", "type": "string"}, "start_cursor": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "If supplied, this endpoint will return a page of results starting after the cursor provided. If not supplied, this endpoint will return the first page of results.", "title": "Start Cursor"}, "page_size": {"anyOf": [{"type": "integer"}, {"type": "null"}], "default": 100, "description": "The number of items from the full list desired in the response. Maximum: 100", "title": "Page Size"}}}, {"name": "API-retrieve-a-block", "description": "Retrieve a block", "tags": ["API-retrieve-a-block"], "status": true, "display_name": "API-retrieve-a-block", "display_description": "Retrieve a block", "readonly": false, "args": {"block_id": {"description": "Identifier for a Notion block", "title": "Block Id", "type": "string"}}}, {"name": "API-update-a-block", "description": "Update a block", "tags": ["API-update-a-block"], "status": true, "display_name": "API-update-a-block", "display_description": "Update a block", "readonly": false, "args": {"block_id": {"description": "Identifier for a Notion block", "title": "Block Id", "type": "string"}, "type": {"anyOf": [{"$ref": "#/$defs/AnonModel0"}, {"type": "null"}], "default": null, "description": "The [block object `type`](ref:block#block-object-keys) value with the properties to be updated. Currently only `text` (for supported block types) and `checked` (for `to_do` blocks) fields can be updated."}, "archived": {"anyOf": [{"type": "boolean"}, {"type": "null"}], "default": true, "description": "Set to true to archive (delete) a block. Set to false to un-archive (restore) a block.", "title": "Archived"}}}, {"name": "API-delete-a-block", "description": "Delete a block", "tags": ["API-delete-a-block"], "status": true, "display_name": "API-delete-a-block", "display_description": "Delete a block", "readonly": false, "args": {"block_id": {"description": "Identifier for a Notion block", "title": "Block Id", "type": "string"}}}, {"name": "API-retrieve-a-page", "description": "Retrieve a page", "tags": ["API-retrieve-a-page"], "status": true, "display_name": "API-retrieve-a-page", "display_description": "Retrieve a page", "readonly": false, "args": {"page_id": {"description": "Identifier for a Notion page", "title": "Page Id", "type": "string"}, "filter_properties": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "A list of page property value IDs associated with the page. Use this param to limit the response to a specific page property value or values. To retrieve multiple properties, specify each page property ID. For example: `?filter_properties=iAk8&filter_properties=b7dh`.", "title": "Filter Properties"}}}, {"name": "API-post-page", "description": "Create a page", "tags": ["API-post-page"], "status": true, "display_name": "API-post-page", "display_description": "Create a page", "readonly": false, "args": {"parent": {"$ref": "#/$defs/AnonModel0"}, "properties": {"$ref": "#/$defs/langflow__base__mcp__util__AnonModel1__3"}, "children": {"anyOf": [{"items": {"type": "string"}, "type": "array"}, {"type": "null"}], "default": null, "description": "The content to be rendered on the new page, represented as an array of [block objects](https://developers.notion.com/reference/block).", "title": "Children"}, "icon": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "The icon of the new page. Either an [emoji object](https://developers.notion.com/reference/emoji-object) or an [external file object](https://developers.notion.com/reference/file-object)..", "title": "Icon"}, "cover": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "The cover image of the new page, represented as a [file object](https://developers.notion.com/reference/file-object).", "title": "Cover"}}}, {"name": "API-retrieve-a-database", "description": "Retrieve a database", "tags": ["API-retrieve-a-database"], "status": true, "display_name": "API-retrieve-a-database", "display_description": "Retrieve a database", "readonly": false, "args": {"database_id": {"description": "An identifier for the Notion database.", "title": "Database Id", "type": "string"}}}, {"name": "API-retrieve-a-page-property", "description": "Retrieve a page property item", "tags": ["API-retrieve-a-page-property"], "status": true, "display_name": "API-retrieve-a-page-property", "display_description": "Retrieve a page property item", "readonly": false, "args": {"page_id": {"description": "Identifier for a Notion page", "title": "Page Id", "type": "string"}, "property_id": {"description": "Identifier for a page [property](https://developers.notion.com/reference/page#all-property-values)", "title": "Property Id", "type": "string"}, "page_size": {"anyOf": [{"type": "integer"}, {"type": "null"}], "default": null, "description": "For paginated properties. The max number of property item objects on a page. The default size is 100", "title": "Page Size"}, "start_cursor": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "For paginated properties.", "title": "Start Cursor"}}}, {"name": "API-retrieve-a-comment", "description": "Retrieve comments", "tags": ["API-retrieve-a-comment"], "status": true, "display_name": "API-retrieve-a-comment", "display_description": "Retrieve comments", "readonly": false, "args": {"block_id": {"description": "Identifier for a Notion block or page", "title": "Block Id", "type": "string"}, "start_cursor": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "If supplied, this endpoint will return a page of results starting after the cursor provided. If not supplied, this endpoint will return the first page of results.", "title": "Start Cursor"}, "page_size": {"anyOf": [{"type": "integer"}, {"type": "null"}], "default": null, "description": "The number of items from the full list desired in the response. Maximum: 100", "title": "Page Size"}}}, {"name": "API-create-a-comment", "description": "Create comment", "tags": ["API-create-a-comment"], "status": true, "display_name": "API-create-a-comment", "display_description": "Create comment", "readonly": false, "args": {"parent": {"$ref": "#/$defs/AnonModel0", "description": "The page that contains the comment"}, "rich_text": {"items": {"$ref": "#/$defs/langflow__base__mcp__util__AnonModel1__2"}, "title": "Rich Text", "type": "array"}}}], "display_name": "Actions", "advanced": false, "dynamic": false, "info": "Modify tool names and descriptions to help agents understand when to use each tool.", "real_time_refresh": true, "title_case": false, "type": "tools", "_input_type": "ToolsInput"}}, "description": "Connect to an MCP server to use its tools.", "icon": "Mcp", "base_classes": ["Message"], "display_name": "MCP Connection", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Tool"], "selected": "Tool", "name": "component_as_tool", "hidden": null, "display_name": "Toolset", "method": "to_toolkit", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "options": null, "tool_mode": true}], "field_order": ["mode", "command", "env", "sse_url", "headers_input", "tool", "tool_placeholder"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": true, "category": "tools", "key": "MCPTools", "score": 0.003932426697386162, "lf_version": "1.4.1", "official": false}, "showNode": true, "type": "MCPTools", "id": "MCPTools-j1UrN"}, "id": "MCPTools-j1UrN", "position": {"x": 0, "y": 0}, "type": "genericNode"}], "viewport": {"x": 1, "y": 1, "zoom": 1}}, "is_component": true, "updated_at": "2025-05-18T00:10:54+00:00", "webhook": false, "endpoint_name": null, "tags": [], "locked": false, "mcp_enabled": true, "action_name": null, "action_description": null, "access_type": "PRIVATE", "id": "4c4b775a-5437-404c-a914-2639b4877e33", "user_id": "154bb2fa-5a61-447f-bdf9-a5b73f8d8516", "folder_id": "a8a36b90-719e-4e7f-b9ab-9208ffd9acff"}